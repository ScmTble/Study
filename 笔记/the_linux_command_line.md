《linux 命令行大全》笔记

只记录未掌握的部分





### 目录

| 目录           | 内容                                                         |
| -------------- | ------------------------------------------------------------ |
| /              | 根目录                                                       |
| /bin           | 包含系统启动和运行的必要文件：linux内核、最初的RAM磁盘镜像和启动加载程序 |
| /boot          | /boot/gurb/gurb.conf 或 menu.lsit，用来配置启动加载程序；/boot/vmlinuz linux内核 |
| /dev           | 设备文件                                                     |
| /etc           | /etc/crontab，该文件定义了自动化任务运行的时间      /etc/fstab，存储设备以及相关挂载点的列表    /etc/passwd，用户帐号列表 |
| /home          | 普通用户目录                                                 |
| /lib           | 包含核心系统程序使用的共享文件                               |
| /lost+found    | 当系统崩溃时，该目录用来恢复分区。如果不出想很严重的问题，文件一般都是空的 |
| /media         | 包含可移除设备的挂载点                                       |
| /mnt           | 早期linux中，包含手动挂载的可移除设备的挂载点                |
| /opt           | 用来安装其他可选软件。主要用来肯安装在系统的商业软件         |
| /proc          | 从文件角度说，该目录不是存储在硬盘中的真正的文件系统，反而是一个linux内核维护的虚拟文件系统。它包含的文件是内核的窥视孔。该文件可读，从内部可以看到内核是如何监管计算机的 |
| /root          | root 用户的主目录                                            |
| /sbin          | “系统”二进制文件，这些程序执行很重要的任务，通常是为超级用户预留的 |
| /tmp           | 供用户存放各类程序创建的临时文件的目录，每次系统重启会清空该目录 |
| /usr           | /usr 目录可能是linux系统中的最大的树目录，包含普通用户使用的所有程序和相关文件 |
| /usr/bin       | 一些linux发行版安装的可执行程序。该目录通常会有上万个程序    |
| /usr/lib       | 程序使用的共享库                                             |
| /usr/local     | 这个目录并非自带的，但打算让系统使用的程序安装目录。源码编译的程序通常安装在/usr/local/bin |
| /usr/sbin      | 包含更多的系统管理程序                                       |
| /usr/share     | 包含了/usr/bin中的程序使用的全部共享数据，包括默认配置、文件、图标、屏幕背景、音频文件等 |
| /usr/share/doc | 安装的文档文件                                               |
| /var           | 除了/tmp和/home目录外，目前看到的目录都是相对静态的。而那些可能改变的数据存储在/var目录树里。各种数据库、假脱机文件、用户邮件都存储在这里 |
| /var/log       | 日志文件，记录了各种系统活动。                               |





### 通配符

| 通配符        | 匹配项                           |
| ------------- | -------------------------------- |
| *             | 匹配任意多个字符(包括0和1)       |
| ?             | 匹配任一个单字符(不包括0)        |
| [characters]  | 匹配任一个属于字符集中的字符     |
| [!characters] | 匹配任一个不属于字符集中的字符   |
| [[:class:]]   | 匹配任一个属于指定字符类中的字符 |

以下是常用的字符类

| 字符类    | 匹配项               |
| --------- | -------------------- |
| [:alnum:] | 匹配任意一个字母数字 |
| [:alpha:] | 匹配任意一个字母     |
| [:digit:] | 匹配任意一个数字     |
| [:lower:] | 匹配任意一个大写字母 |
| [:upper:] | 匹配任意一个小写字母 |





### 链接

- 创建硬链接

  ```shell
  ln file link
  ```

- 创建符号链接 (item == file / directory)

  ```shell
  ln -s item link
  ```

#### 硬链接

​	硬链接是最初UNIX系统创建链接的方式，符号链接更加先进。默认情况下，每个文件都有一个硬链接，硬链接会给文件取名字，当创建硬链接的时候也为这个文件创建了一个额外的目录条目。硬链接有两个重要的局限性：

- 硬链接不能引用文件系统之外的文件。也就是不能引用与该链接不再同一磁盘分区的文件。
- 硬链接无法引用目录

#### 符号链接

> lrwxrwxrwx 1 root root

​	l 代表软链接(symlink)，如果是 d 代表是文件夹，没有就是文件。软链接就是使一个程序有多个名字，这样文件名可以加上版本号，但不用考虑升级后调用该文件的程序更新调用名称。



### 手册

#### man手册结构

| 部分 | 内容                           |
| ---- | ------------------------------ |
| 1    | 用户命令                       |
| 2    | 内核系统调用的程序接口         |
| 3    | C库函数程序接口                |
| 4    | 特殊文件、如设备节点和驱动程序 |
| 5    | 文件格式                       |
| 6    | 游戏和娱乐，例如屏幕保护程序   |
| 7    | 其他杂项                       |
| 8    | 系统管理命令                   |

```shell
man 1 ls
```





### 重定向

- 普通重定向

  ```shell
  ls -l /etc > ls-etc.txt 
  ```

- 错误重定向

  ```shell
  ls -l /666 2> err.conf
  ```

0 代表输入文件，1 代表输出文件，2 代表错误输出文件。可以将错误重定向到位桶中来抑制错误信息。



#### 位桶(bit bucket)

/dev/null 是一个被成为位桶的设备，它接受输入但是不对输入进行任何处理。可以用来隐藏一个命令的错误信息。



#### 标准输入重定向

cat 合并文件，cat 读取一个或多个文件，并把他们复制到标准输出文件中。

例如有些多媒体文件经常被拆分，可以用cat还原为原文件

```shell
cat movie.mepg.001 move.mepg.002 ... movie.mepg.009 > movie.mpeg
```

这样来接受标准输入(输出文件内容)

```shell
cat < file
```



#### 管道

管道 | (竖线)，可以把一个命令的标准输出传入到另一个命令里面

```shell
command | command
```



#### 过滤器

```shell
ls /bin /usr/bin | sort | less
```

管道可以对数据进行复杂操作，多条命令结合在一起被称为过滤器(filter)



#### uniq 报告或忽略文件中重复的行

uniq命令一般结合 sort 命令使用，可删去重复行

```shell
ls /bin /usr/bin | sort | uniq | less
```

还可以只看重复的内容

```shell
ls /bin /usr/bin | sort | uniq -d | less
```



#### wc 打印行数、字数和字节数

字数统计(word count)用来先生文件中包含的行数字数和字节数

```shell
wc file
```



#### grep 打印匹配行

```shell
grep pattern [file...]
```



#### head / tail 打印文件的开头 / 结尾部分

```shell
head -n 5 file
```

````shell
tail -n 5 file
````

这些命令也可以用在管道里

```shell
ls /usr/bin | tail -n 8
```

tail 命令有个功能可以用来监视正在被写入的文件

```shell
tail -f /var/log/messages
```



#### tee 从stdin读取数据，并输出到stdout 和 文件

```shell
ls /usr/bin | tee s.txt | grep zip
```



### 扩展

将字符序列（比如*）处理成结果的过程被称为扩展(expansion)

#### 路径名扩展

通过使用通配符扩展路径名叫做路径名扩展(pathname expansion)

```shell
echo *
echo D*
echo [[:upper:]]*
```

#### 隐藏文件的路径名扩展

```shell
ls -d .[!.]?*
```

点代表以点开头，感叹号代表不匹配点，问好代表至少匹配一个符号，星号则代表可以匹配更多

#### 波浪线扩展

～ 代表用户目录

```shell
echo ~
```

如果有user用户

```shell
echo ~user
```

#### 算术扩展

```shell
echo $((2+3))
```

算数扩展如下格式

```shell
((expression))
```

expression 为算数表达式

| 运算符 | 描述 |
| ------ | ---- |
| +      | 加   |
| -      | 减   |
| *      | 乘   |
| /      | 除   |
| %      | 取余 |
| **     | 取幂 |

#### 花括号扩展

花括号扩展(brace expansion)可能是最奇怪的扩展方式了，有了花括号里面的模式创建多种文本字符串

```shell
echo Front-{A,B,C}-Back
```

花括号扩展的信息模式可以包括一个称为**前导字符**(**preamble**)的开头部分和一个称为**附言**(**postscript**)的结尾部分。花括号表达式本身可以包含一系列逗号分隔符的字符串，也可以包含一系列整数或者单个字符

```shell
echo Number-{1..10}
```

一系列字母

```shell
echo {Z..A}
```

花括号扩展支持嵌套

```shell
echo a{A{1,2}, B{3,4}}
```

花括号扩展可用于创建一堆文件(2015到2020每月一份文件夹)

```shell
mkdir {2015..2020}-0{1..9} {2015..2020}-{10..12}
```





#### 参数扩展

使用 printenv 命令来查看参数列表

```shell
printenv | less
```

例如用户变量

```shell
echo $USER
```

shell 

```shell
echo $SHELL
```





#### 命令替换

命令替换把一个命令的输出作为一个扩展模式使用

```shell
echo $(ls)
```

还有更好的用法

```shell
ls -l $(which cp)
```

这里将 which cp 作为 ls 命令的参数使用







### 引用

先看个例子

```shell
echo Total is $100.00
```

> (bash)	Total is 00.00
>
> (zsh)	Totoal is .00

由于 $1 是一个未定义的变量，所以参数扩展将其替换为空白字符，不同的 shell 的处理方式会有些不同

为了避免不想要的扩展，shell 提供了一种称为引用(quoting)的机制





#### 双引号

双引号引用(double quote)可以使单词扩展、路径名扩展、波浪线扩展和花括号扩展都失效，但不会使命令扩展和算数扩展失效。

空格、制表符和换行符会被当成单词的分割符，将其分为不同的参数，而加了双引号后这些符号就成了文本的一部分

````shell
echo "This is a test."
````



#### 单引号

如果希望抑制所有的扩展，那就要使用单引导

```shell
echo '$USER' 
```

> $USER



#### 转义字符

如果只想要引用单个字符，可以在该字符前加上反写杠来实现

```shell
echo \$5.00
```

转义字符也可以用来消除某个字符的特殊含义(例如 $ ! &)

```shell
echo A\&B
```

如果要显示反斜杠可以使用两个反斜杠来实现

```shell
echo \\
```









### Bash组合键

- 光标移动

  | 组合键 | 作用                 |
  | ------ | -------------------- |
  | Ctrl-A | 移动光标到行首       |
  | Ctrl-E | 移动光标到行末       |
  | Ctrl-F | 光标向前移动一个字符 |
  | Ctrl-B | 光标向后移动一个字符 |
  | Ctrl-L | 清屏                 |
  | Alt-F  | 光标向前移动一个单词 |
  | Alt-B  | 光标向后移动一个单词 |

- 修改文本

  | 组合键 | 作用                             |
  | ------ | -------------------------------- |
  | Ctrl-D | 删除光标处的字符                 |
  | Ctrl-T | 使光标处字符和它前面字符对调位置 |
  | Alt-T  | 使光标处字符和它后面字符对调位置 |
  | Alt-L  | 把光标到末尾的字符换成小写模式   |
  | Alt-U  | 把光标到末尾的字符换成大写模式   |

- 剪切和粘贴文本(Killing and Yanking)

  | 组合键        | 作用                                    |
  | ------------- | --------------------------------------- |
  | Ctrl-K        | 剪切从光标到末尾的文本                  |
  | Ctrl-U        | 剪切从光标到行首的文本                  |
  | Alt-D         | 剪切从光标到当前词尾的文本              |
  | Alt-Backspace | 剪切从光标到词头的文本                  |
  | Ctrl-Y        | 把 kill-ring 缓冲区的文本粘贴到光标位置 |



#### 历史命令

```bash
history | less
```

从历史命令中搜索某条命令

```shell
history | grep vim
```

通过**历史记录扩展**(**history expansion**)查看历史命令

```shell
!88
```

该命令会返回历史记录中第88条命令

bash(zsh)还支持更多的历史记录搜索方式

| 组合键 | 作用                                                       |
| ------ | ---------------------------------------------------------- |
| Ctrl-P | 移动到前一条历史记录                                       |
| Ctrl-N | 移动到后一条历史记录                                       |
| Ctrl-R | 搜索历史记录                                               |
| Alt-<  | 移动到历史记录列表开始处                                   |
| Alt->  | 移动到历史记录列表结束处                                   |
| Alt-P  | 逆向非递增地搜索，按下Enter后才开始搜索                    |
| Alt-N  | 向前非递增地搜索                                           |
| Ctrl-O | 执行历史记录中的当前项，然后条到下一项。可遍历执行历史记录 |



#### 历史记录扩展

| 序列      | 行为                           |
| --------- | ------------------------------ |
| !!        | 重复最后一个执行的命令         |
| !number   | 重复历史记录中第number个命令   |
| ！ string | 重复最近以string开头的历史命令 |
| !?string  | 重复最近的包括string的历史命令 |







### 所有者、组成员和其他所有用户

```shell
file /etc/shadow
```

> /etc/shadow: regular file, no read permission

普通用户并没有对该文件的访问权限，因此会有这样的输出

在UNIX安全模型中，一个用户可以拥有(own)文件和目录。该用户具有对家目录的访问权限拥有控制权，同时一个用户又属于一个用户组(group)，该群组由一个或多个用户组成，组中用户对文件和目录的访问权限由其所有者授予。

在UNIX术语中，所有用户指整个世界(world)。使用id命令可以获得用户身份标识的相关信息

```shell
id
```



#### 读取、写入和执行

```shell
ls -l /etc/resolv.conf
```

> -rw-r--r-- 1 root root 73  9月  3 19:24 /etc/resolv.conf

- 输出前十个字母是文件属性(file attribute)，其中第一个字符表示文件类型(file type)

  | 1    | 2    | 3    | 4    |
  | ---- | ---- | ---- | ---- |
  | -    | rw-  | r--  | r--  |

  1. 文件类型

     | 属性 | 文件类型                                                     |
     | ---- | ------------------------------------------------------------ |
     | -    | 普通文件                                                     |
     | d    | 目录文件                                                     |
     | l    | 符号链接。对于符号链接文件，剩下的文件属性始终是rwxrwxrwx，它是一个伪属性值。链接指向的文件属性才是真正的文件属性 |
     | c    | 字符设备文件。该文件类型表示一字节留形式处理数据的设备，例如终端 |
     | b    | 快设备文件，该文件类型表示以数据块处理数据的设备，例如磁盘驱动和光盘驱动 |

  2. 所有者权限

  3. 组权限

  4. 其他用户权限

权限属性

| 属性 | 文件                                                         | 目录                                                   |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------ |
| r    | 允许打开读取文件                                             | 如果有执行权限，那么允许列出目录下的内容               |
| w    | 允许写入和截短文件:如果也设置了执行权限，那么目录中的文件允许被创建、删除以及重命名 | 但是该权限不允许重命名和删除文件，该权限由目录权限决定 |
| x    | 允许把文件当作程序来执行。用脚本语言写的程序文件必须为可读才能被执行 | 允许进入目录下                                         |



#### chmod 更改文件模式

chmod支持两种模式：八进制法 和 符号表示法

- 八进制数字表示法

  八进制(octal) 和 十六进制(hexadecimal)

  八进制法表示使用八进制数字来设置所期望的权限模式。每个八进制数对因3个二进制数，所以刚好用来存储文件模式的结构方式——映射

  | 八进制 | 二进制 | 文件模式 |
  | ------ | ------ | -------- |
  | 0      | 000    | ---      |
  | 1      | 001    | --x      |
  | 2      | 010    | -w-      |
  | 3      | 011    | -wx      |
  | 4      | 100    | r--      |
  | 5      | 101    | r-x      |
  | 6      | 110    | rw-      |
  | 7      | 111    | rwx      |

- 符号表示法

  chmod 命令支持一种符号表示法来指定文件模式。该符号表示法分为三部分：更改会影响

  谁、要执行哪个操作、要设置那种权限。可以通过字符u、g、o、a的组合来指定要影响的对象。

| 符号 | 含义                                  |
| ---- | ------------------------------------- |
| u    | user 的简写，表示文件或者目录的所有者 |
| g    | 文件所属群组                          |
| o    | others的简写，表示其他所有用户        |
| a    | all的简写，u g o的组合                |

权限字符用r、w、x来指定，如果不指定用户默认为all.

用法：

```shell
[ugoa...][[-+=][perms...]...]
```

| 符号  | 含义                                     |
| ----- | ---------------------------------------- |
| u+x   | 为文件所有者添加执行权限                 |
| u-x   | 删除文件所有者的执行权限                 |
| +x    | 为所有用户添加可执行权限                 |
| go=rw | 只给予文件所属用户组和其他用户组读写权限 |



#### umask 设置默认权限

umask 命令控制这创建文件时指定给文件的默认权限，它用八进制表示法从文件模式中删除一个位掩码。

```shell
umask
```

> 002

0022是另一个常用的值

0002:

| 原始文件模式 | ---  | rw-  | rw-  | rw-  |
| ------------ | ---- | ---- | ---- | ---- |
| 掩码         | 000  | 000  | 000  | 010  |
| 结果         | ---  | rw-  | rw-  | r--  |

0022:
| 原始文件模式 | ---  | rw-  | rw-  | rw-  |
| ------------ | ---- | ---- | ---- | ---- |
| 掩码         | 000  | 000  | 000  | 010  |
| 结果         | ---  | rw-  | r--  | r--  |

大多数情况是不需要改变掩码值的，在一些高安全级别的环境上才需要控制掩码的值。

通常看到的八进制权限掩码都是用三位数字表示的，但技术上来说它还是四位数字表示的。



### 更改权限

- su 以其他用户和组ID的身份运行shell

  su 命令以另一个用户身份启动shell

  ```shell
  su [-[l]] [user]
  ```

  如果包含 -l 选项，那么得到的shell绘画界面将是用于指定用户的login shell界面。这意味着，该指定用户的运行环境将被加载，且工作目录也将变为该用户的主目录

  如果没有指定用户，默认为超级用户，同时-l可以缩写为-

  ```shell
  su -
  ```

  还可以单条执行命令

  ```shell
  su -c 'command'
  ```

- sudo 以另一个用户身份执行命令

  sudo 并不需要输入超级用户的密码，使用sudo命令时用户只需要用自己密码来验证。sudo 与 su 的一个重要区别在于，sudo命令并不需要启动一个新的shell环境，而且也不需要加载另一个用户的运行环境，这意味着，使用sudo命令的时候并不需要单引号把命令行引起来。

  使用sudo -l 来查看sudo命令授予了哪些权限

  ```shell
  sudo -l
  ```



#### chown 更改文件所有者和所属群组

chown(change owner) 命令用来更改文件或者目录的所有者和所属群组，使用这个命令需要超级用户

```shell
chown [ower] [:[group]] file
```

chown 命令参数实例

| 参数      | 结果                                                         |
| --------- | ------------------------------------------------------------ |
| bob       | 把文件所有者从当前所有者更改为用户bob                        |
| bob:users | 把文件所有者从当前所有者更改为用户bob，并把文件所属群组改为users群组 |
| :admins   | 把文件所属群组改为admins群组                                 |
| bob:      | 把文件所有者从当前所有者更改为用户bob，并把文件所属群组更改为用户bob登陆时所在群组 |



#### chgrp 更改文件所属群组

在早期的UNIX版本中，chown命令只能更改文件所有者，而不能改变所属群组，于是就有了chgrp(change group) 命令，用法和chown命令几乎相同。



#### 更改用户密码

```shell
passwd [user]
```

直接更改目前用户的密码

```shell
passwd
```

如果有超级用户权限还可以指定用户名作为passwd参数为另一个用户设置密码。对于超级用户还可以使用该命令的其他参数来设置账户锁定、密码失效等功能







### 进程

现代操作系统都支持多重任务处理(multitasking)，多重任务处理是指系统通过切换运行中的程序来实现多任务同时执行。linux内核通过使用进程来管理多重任务，进程就是linux用来安排不同程序等待CPU调度的一种组织方式。

- 进程如何工作

    系统启动时内核先将一些初始程序化为进程，然后运行一个称为init的程序，init程序将依次运行一系列称为脚本初始化(init scrpit)的shell脚本(under /etc)，这些脚本会启动所有系统服务。其中许多服务都是通过守护进程(daemon program)实现的。

    内核会保存每个进程的信息以确保任务有序进行，每个进程会分配一个进程ID (PID, process ID)，按照递增的方式分配，init 进程的PID始终为1。和文件系统类似，进程系统也存在用户ID、有效用户ID等

#### 使用ps命令查看进程信息

```shell
ps
```

>    PID TTY      TIME CMD 
>   1270 pts/1   00:00:00 zsh 
>   2022 pts/1   00:00:00 ps

TTY 是 teletype（电话打字机）的缩写，代表了进程的字符终端(controlling termianl)。UNIX也显示了子进程的运行时间，TIME字段表示了消耗的CPU的时间总和。

```shell
ps x
```

> PID TTY    STAT  TIME COMMAND 
> 613 ?     Ss   0:00 /usr/lib/systemd/systemd --user 
> 614 ?     S    0:00 (sd-pam) 
> 628 ?     Sl   0:00 /usr/bin/kwalletd5 --pam-login 7 3 
> 629 ?     Sl   0:00 /usr/bin/startplasma-x11 
> 632 ?     ZN   0:00 [zsh] <defunct>
>
> ...

添加x选项告知ps命令显示所有的进程，而不在乎是哪个终端控制的。TTY列中列出的"?"表示没有控制终端。输出结果中添加了一个命名为STAT的新列，STAT是 state 的缩写，显示的是进程的当前状态。

| 状态 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| R    | 运行状态。进程正在运行或者准备运行                           |
| S    | 睡眠状态。进程不在运行，而是在等待某件事发生，例如键盘输入或者网络报文 |
| D    | 不可中断的睡眠状态。进程在等待I/O操作，例如硬盘驱动          |
| T    | 暂停状态。进程被指示暂停                                     |
| Z    | 无效或者"僵尸"进程。进程被终止但是还未被父进程彻底释放       |
| <    | 高级有限进程。进程可以被赋予更多的重要性，分配更多的CPU时间。这一特性成为优先级(niceness) |
| N    | 低级优先级进程。(a nice process)只有在其他高级优先级的进程使用完处理后才能使用处理器的时间 |

另一个常用组合是 aux，这种不带前缀的命令是"BSD模式(BSD-style)"

```shell
ps aux
```

| 标题  | 含义                       |
| ----- | -------------------------- |
| USER  | 用户ID。该进程所有者       |
| %CPU  | CPU占用比                  |
| %MEN  | 内存使用比                 |
| VSZ   | 虚拟内存使用大小           |
| RSS   | 世纪使用内存大小。KB为单位 |
| START | 进程开启时间。             |



#### 使用 top 命令查看进程

ps 命令查看的是某时刻的机器状态的一个快照，top则是实时更新系统的进程信息。

```shell
top
```

进入程序后使用命令 h 可以查看帮助界面，q 键退出





#### 控制进程

例如在shell中启动一个有图像界面的软件

```shell
kwrite
gedit
```

使用 Ctrl-C 来中断(interrupt)进程

- 使进程在后台(background)运行

  ```shell
  gedit &
  ```

  > [1] 2777

  在后面加一个 & 符号来实现将程序放在后台运行。上面的输出是 shell 的作业控制符(job control)的特征表现，作业编号为 1 ，其对应PID为2777。

- 使用 jobs 命令查看

  ```shell
  jobs
  ```

  > [1]  + running   gedit

- 将任务放到前台执行

  ```shell
  fg %1
  ```

  也可以使用 bg 将任务放到后台执行

  ```shell
  bg %1
  ```

- 停止（暂停）进程

  使用 Ctrl-Z 来暂停进程，暂停后可以将进程放到前端或后端进行



#### 信号

kill 命令可以通过使用进程的PID来“杀死”（终止）进程，用来终止不正常的程序或者反过来拒绝终止的程序。

```shell
kill 3421
```

kill 命令准确的来说并不是“杀死”进程，而是给进程发信号(signal)。信号是操作系统和程序间通信的多种方式之一，Ctrl-C 和 Ctrl-Z 都是这种方式。当终端接收到其中一个输入中，它将发送信号到前台进程，按下Ctrl-C时会发送一个INT(终端，Interrupt)的信号，按下Ctrl-Z会发送一个称为TSTP(终端暂停，Terminal Stop)的信号。



#### 使用 kill 命令发送信号到进程

